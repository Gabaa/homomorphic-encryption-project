\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{parskip}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{todonotes}

% Code environment (incomplete)
\lstset{
  basicstyle=\ttfamily,
}

\begin{document}

\section{Implementation}

\todo{Dette skal nok opdateres når vi er færdige med implementationen. Skal inkludere det om MPC.}
We implemented a somewhat-homomorphic public-key encryption scheme in the Rust programming language, as well as functions for adding and multiplying ciphertexts for that encryption scheme.
\todo{Hvor meget skal forklares her? At det er Brakersky-Vaikuntanathan vi implementerede? At det er baseret på Ring-LWE? Eller bliver det alt sammen beskrevet et andet sted?}

\subsection{Polynomials (\lstinline{poly.rs})}

Since our public-key encryption scheme uses polynomials to represent all of the values we work on (messages, ciphertexts, secret keys, and public keys), we made an implementa

\subsection{Public-key encryption scheme (\lstinline{encryption.rs})}

The encryption scheme, as usual, has three major components:

\begin{itemize}
  \item the \lstinline{generate_key_pair} function
  \item the \lstinline{encrypt} function
  \item and the \lstinline{decrypt} function
\end{itemize}

\subsubsection{\lstinline{generate_key_pair}}

The \lstinline{generate_key_pair} function takes as input an instance of the \lstinline{Parameters} struct.
This struct essentially just defines the parameters that nearly all functions in the encryption scheme use in some form or another.
This includes $r$, $n$, $q$, $t$, and the quotient ring $R_q$, which are all relevant for the key generation function.

The function starts by sampling polynomials $sk$ and $e_0$ from a Gaussian distribution with standard deviation $r$, and the polynomial $a_0$ uniformly from $\mathbb{Z}_q$.

It then calculates the public-key as $pk = (a_0, a_0 \cdot sk + e_0 \cdot t)$, and finally returns the key pair $(pk, sk)$.

\subsubsection{\lstinline{encrypt}}

The \lstinline{encrypt} function takes a \lstinline{Parameters} instance, as described above, and additionally takes a polynomial $m$ and a public key $pk$.

We extract the two polynomials of the public key, $a_0$ and $b_0$.

First, we make sure that the message polynomial we are trying to encrypt is in $R_t$.
Then, we sample polynomials $v$ and $e'$ from a Gaussian distribution with standard deviation $r$, and the polynomial $e''$ from a Gaussian distribution with standard deviation $r'$ (which is also defined in the \lstinline{Parameters} struct).

We then calculate $a = a_0 \cdot v + e' \cdot t$ and $b = b_0 \cdot v + e'' \cdot t$.
Finally, we create the ciphertext as a \lstinline{Vec} (a contiguous growable array type) $c = [b + m, a]$ and return it.

\subsubsection{\lstinline{decrypt}}

The \lstinline{decrypt} function takes a \lstinline{Parameters} instance, as well as a ciphertext $c = [c_0, c_1, \dots]$ and a secret key $sk$.

We start by constructing the secret key vector $\mathbf{s} = [1, s, s^2, \dots]$ from the secret key.
We only create the first $|c|$ entries of the secret key vector, as those are the only ones we'll need.

We then initialize a polynomial $msg = 0$, which will become the decrypted message.
Then, iterating over each element $c_i$ in the ciphertext, we add $c_i \cdot \mathbf{s}_i$ to $msg$, where $\mathbf{s}_i$ is the $i$'th entry (zero-indexed) in the secret key vector.

\todo{Skal nok lige have nogle andre til at tilpasse denne - jeg har svært ved at finde ud af hvordan man forklarer det.}
Currently, the message has coefficients in $\mathbb{Z}_q$, but we need them to be in the range $-\frac{q}{2}$ to $\frac{q}{2}$.
\todo{Er det inklusive eller eksklusive i intervallet?}
Therefore, we iterate through all coefficients $x$ and map them to the new range such that if $x > \frac{q}{2}$, then we let $x' = x - q$, and otherwise $x' = x$.

Finally, we reduce the message modulo $t$ to remove the $e \cdot t$ part of the encryption, and return the result.

\subsection{Evaluating functions on ciphertexts (\lstinline{encryption.rs})}

Since this encryption scheme is somewhat-homomorphic, we have implemented functions for adding and multiplying ciphertexts (the functions \lstinline{add} and \lstinline{mul} respectively).

\subsection{Choosing parameters for the encryption scheme}

\end{document}
